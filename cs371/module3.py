# AUTOGENERATED! DO NOT EDIT! File to edit: module3.ipynb (unless otherwise specified).

__all__ = ['MyDisjointSet', 'MyDisjointSet2', 'MyDisjointSet3', 'DisjointSetsForest', 'DisjointSetsPathCompression',
           'DisjointSetsTwoPassPC', 'DisjointSetsMergeByHeight', 'DisjointSetsMergeByHeight2',
           'DisjointSetsMergeByHeight3', 'DisjointSetsMergeByWeight', 'DisjointSetsMergeByHeightAndPathCompression',
           'DisjointSetsMergeByHeightAndPathCompression2']

# Cell
import numpy as np

from .utils import *

# Cell
class MyDisjointSet:
    def __init__(self, N):
        self.N = N
        self.bubbles = [{i} for i in range(N)]

    def _get_bubble_idx(self, val):
        for idx, bubble in enumerate(self.bubbles):
            if val in bubble: return idx
        return -1

    def find(self, i, j):
        idx1, idx2 = map(self._get_bubble_idx, [i, j])
        if idx1 != -1 and idx1 == idx2: return True
        else:                           return False

    def union(self, i, j):
        idx1, idx2 = map(self._get_bubble_idx, [i, j])
        if idx1 != -1 and idx2 != -1 and idx1 != idx2:
            self.bubbles[idx1] = self.bubbles[idx1] | self.bubbles[idx2]
            del self.bubbles[idx2]

# Cell
class MyDisjointSet2:
    def __init__(self, N):
        self.N = N
        self.idx_bubbles = np.arange(N)

    def _get_bubble_idx(self, val): return self.idx_bubbles[val]

    def find(self, i, j):
        idx1, idx2 = map(self._get_bubble_idx, [i, j])
        if idx1 != -1 and idx1 == idx2: return True
        else:                           return False

    def union(self, i, j):
        idx1, idx2 = map(self._get_bubble_idx, [i, j])
        if idx1 != -1 and idx2 != -1 and idx1 != idx2:
            idx1, idx2 = np.sort([idx1, idx2])
            self.idx_bubbles[self.idx_bubbles == idx2] = idx1

# Cell
class MyDisjointSet3:
    def __init__(self, N):
        self.N = N
        self.parents = np.arange(N)

    def _get_root(self, val):
        if self.parents[val] != val: return self._get_root(self.parents[val])
        else:                        return val

    def find(self, i, j):
        root_i = self._get_root(i)
        root_j = self._get_root(j)
        return root_i == root_j

    def union(self, i, j):
        root_i = self._get_root(i)
        root_j = self._get_root(j)
        if not self.find(i, j):
            self.parents[root_j] = root_i

# Cell
class DisjointSetsForest:
    def __init__(self, L):
        self._parent = {item : item for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            item = self._parent[item]
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        if not self.find(a,b):
            self._parent[self._root(b)] = self._root(a)

# Cell
class DisjointSetsPathCompression:
    def __init__(self, L):
        self._parent = {item : item for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            parent = self._parent[item]
            self._parent[item] = self._parent[parent]
            item = parent
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        if not self.find(a,b):
            self._parent[self._root(b)] = self._root(a)

# Cell
class DisjointSetsTwoPassPC:
    def __init__(self, L):
        self._parent = {item : item for item in L}

    def _root(self, item):
        root = item
        while root is not self._parent[root]:
            root = self._parent[root]
        self._compress(item, root)
        return root

    def _compress(self, item, root_new):
        while item is not self._parent[item]:
            item_next = self._parent[item]
            self._parent[item] = root_new
            item = item_next

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        if not self.find(a,b):
            self._parent[self._root(b)] = self._root(a)

# Cell
class DisjointSetsMergeByHeight:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._height = {item : 0 for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            item = self._parent[item]
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        if not self.find(a,b):
            if self._height[a] < self._height[b]:
                a,b = b,a
            self._parent[self._root(b)] = self._root(a)
            self._height[a] = max(self._height[a], self._height[b] + 1)

# Cell
class DisjointSetsMergeByHeight2:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._height = {item : 0    for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            item = self._parent[item]
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        a = self._root(a)                                             # Replace with "representative" node
        b = self._root(b)                                             # Replace with "representative" node
        if a is not b:                                                # find operation
            if self._height[a] < self._height[b]: a, b = b, a         # Make sure "a" has larger height
            self._parent[b] = a                                       # Make root of b a
            self._height[a] = max(self._height[a], self._height[b]+1) # Update height of a

# Cell
class DisjointSetsMergeByHeight3:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._height = {item : 0    for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            item = self._parent[item]
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        a = self._root(a)                                             # Replace with "representative" node
        b = self._root(b)                                             # Replace with "representative" node
        if a is not b:                                                # `find` operation
            self._parent[b] = a                                       # Make root of b a
            self._height[a] = max(self._height[a], self._height[b]+1) # Update height of a

# Cell
class DisjointSetsMergeByWeight:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._weight = {item : 1    for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            item = self._parent[item]
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        a = self._root(a)                                             # Replace with "representative" node
        b = self._root(b)                                             # Replace with "representative" node
        if a is not b:                                                # find operation
            if self._weight[a] < self._weight[b]: a, b = b, a         # Make sure "a" has larger height
            self._parent[b] = a                                       # Make root of b a
            self._weight[a] = self._weight[a] + self._weight[b]       # Update weight of a

# Cell
class DisjointSetsMergeByHeightAndPathCompression:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._weight = {item : 1    for item in L}

    def _root(self, item):
        while item is not self._parent[item]:
            parent = self._parent[item]
            self._parent[item] = self._parent[parent]
            item = parent
        return item

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        a = self._root(a)                                             # Replace with "representative" node
        b = self._root(b)                                             # Replace with "representative" node
        if a is not b:                                                # find operation
            if self._weight[a] < self._weight[b]: a, b = b, a         # Make sure "a" has larger height
            self._parent[b] = a                                       # Make root of b a
            self._weight[a] = self._weight[a] + self._weight[b]       # Update weight of a

# Cell
class DisjointSetsMergeByHeightAndPathCompression2:
    def __init__(self, L):
        self._parent = {item : item for item in L}
        self._weight = {item : 1    for item in L}

    def _root(self, item):
        root = item
        while root is not self._parent[root]:
            root = self._parent[root]
        self._compress(item, root)
        return root

    def _compress(self, item, root_new):
        while item is not self._parent[item]:
            item_next = self._parent[item]
            self._parent[item] = root_new
            item = item_next

    def find(self, a, b):
        return self._root(a) is self._root(b)

    def union(self, a, b):
        a = self._root(a)                                             # Replace with "representative" node
        b = self._root(b)                                             # Replace with "representative" node
        if a is not b:                                                # find operation
            if self._weight[a] < self._weight[b]: a, b = b, a         # Make sure "a" has larger height
            self._parent[b] = a                                       # Make root of b a
            self._weight[a] = self._weight[a] + self._weight[b]       # Update weight of a