# AUTOGENERATED! DO NOT EDIT! File to edit: module19.ipynb (unless otherwise specified).

__all__ = ['Heap3']

# Cell
import numpy as np
import matplotlib.pyplot as plt

from .utils import *

# Cell
class Heap3:
    def __init__(self, entries=None):
        if entries is None: entries = []
        self._entries = entries
        if entries:
            self._heapify()

    def _i_parent(self, i):  return (i-1) // 2
    def _i_child_L(self, i): return 2*i + 1
    def _i_child_R(self, i): return 2*i + 2

    def _swap(self, i1, i2):
        self._entries[i1], self._entries[i2] = self._entries[i2], self._entries[i1]

    def _i_children(self, i):
        i_L = self._i_child_L(i)
        return range(i_L, min(i_L+2, len(self._entries)))

    def _downheap(self, i_parent):
        i_children = self._i_children(i_parent)
        if i_children:
            i_child_max = max(i_children, key=lambda i: self._entries[i][0])
            key_parent, key_child_max = self._entries[i_parent][0], self._entries[i_child_max][0]
            if key_parent < key_child_max:
                self._swap(i_parent, i_child_max)
                self._downheap(i_child_max)

    def pop_max(self):
        val_max = None
        if self._entries:
            val_max, val_last = self._entries[0], self._entries.pop()
            if self._entries:
                self._entries[0] = val_last
                self._downheap(0)
        return val_max

    def _upheap(self, i_child):
        i_parent = self._i_parent(i_child)
        if i_parent >= 0:
            key_parent, key_child = self._entries[i_parent][0], self._entries[i_child][0]
            if key_parent < key_child:
                self._swap(i_parent, i_child)
                self._upheap(i_parent)

    def add(self, val):
        self._entries.append(val)
        self._upheap(len(self._entries)-1)

    def _heapify(self):
        for i in reversed(range(len(self._entries))):
            self._downheap(i)

    def __len__(self):
        return len(self._entries)